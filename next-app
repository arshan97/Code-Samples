import { create } from "zustand"
import { format } from "date-fns"

// Define a type for our timeline data points
export interface TimelineDataPoint {
  timestamp: Date
  label: string
  isLatest: boolean
}

// Define the store state
interface HistoryState {
  // Timeline points
  timelinePoints: TimelineDataPoint[]
  // Selected timeline point
  selectedTimePoint: TimelineDataPoint | null
  // Raw timestamps from the JSON
  rawTimestamps: Date[]
  // Track if user has made a manual selection
  hasManualSelection: boolean
  // Actions
  setTimelinePoints: (points: TimelineDataPoint[]) => void
  setRawTimestamps: (timestamps: Date[]) => void
  generateTimelineFromTimestamps: () => void
  setSelectedTimePoint: (point: TimelineDataPoint | null, isManual?: boolean) => void
}

// Create the store
export const useHistoryStore = create<HistoryState>((set, get) => ({
  timelinePoints: [],
  selectedTimePoint: null,
  rawTimestamps: [],
  hasManualSelection: false,

  setTimelinePoints: (points) => set({ timelinePoints: points }),

  setRawTimestamps: (timestamps) => {
    set({ rawTimestamps: timestamps })
    // After setting raw timestamps, generate the timeline
    get().generateTimelineFromTimestamps()
  },

  generateTimelineFromTimestamps: () => {
    const { rawTimestamps, hasManualSelection, selectedTimePoint } = get()

    if (rawTimestamps.length === 0) {
      // If no timestamps, create a default point with current time
      const now = new Date()
      const defaultPoint = {
        timestamp: now,
        label: format(now, "h:mm a"),
        isLatest: true,
      }

      set({
        timelinePoints: [defaultPoint],
        selectedTimePoint: defaultPoint,
        hasManualSelection: false,
      })
      return
    }

    // Sort timestamps in ascending order (oldest first)
    const sortedTimestamps = [...rawTimestamps].sort((a, b) => a.getTime() - b.getTime())

    // Create timeline points from all timestamps
    const timelinePoints: TimelineDataPoint[] = sortedTimestamps.map((timestamp, index) => {
      const isLatest = index === sortedTimestamps.length - 1
      return {
        timestamp,
        label: format(timestamp, "h:mm a"),
        isLatest,
      }
    })

    set({ timelinePoints })

    // Auto-select latest point logic:
    // 1. If no point is currently selected (initial load) → select latest
    // 2. If user hasn't made manual selection (polling refresh) → select latest
    const latestPoint = timelinePoints[timelinePoints.length - 1]

    if (!selectedTimePoint || !hasManualSelection) {
      console.log("Auto-selecting latest point:", latestPoint?.label, "hasManualSelection:", hasManualSelection)
      set({
        selectedTimePoint: latestPoint,
        // Keep hasManualSelection as is - don't reset it here
      })
    } else {
      console.log("Preserving manual selection:", selectedTimePoint?.label, "hasManualSelection:", hasManualSelection)
    }
  },

  setSelectedTimePoint: (point, isManual = false) => {
    console.log("Setting selected point:", point?.label, "isManual:", isManual)
    set({
      selectedTimePoint: point,
      // Set hasManualSelection to true if this is a manual selection
      hasManualSelection: isManual || get().hasManualSelection,
    })
  },
}))
