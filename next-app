import { create } from "zustand"
import { format } from "date-fns"

// Define a type for our timeline data points
export interface TimelineDataPoint {
  timestamp: Date
  label: string
  isLatest: boolean
}

// Define the store state
interface HistoryState {
  // Timeline points
  timelinePoints: TimelineDataPoint[]
  // Selected timeline point
  selectedTimePoint: TimelineDataPoint | null
  // Raw timestamps from the JSON
  rawTimestamps: Date[]
  // Track if user has made a manual selection
  hasManualSelection: boolean
  // Actions
  setTimelinePoints: (points: TimelineDataPoint[]) => void
  setRawTimestamps: (timestamps: Date[]) => void
  generateTimelineFromTimestamps: () => void
  setSelectedTimePoint: (point: TimelineDataPoint | null, isManual?: boolean) => void
  // New action to force auto-select latest on polling
  autoSelectLatestOnPolling: () => void
}

// Create the store
export const useHistoryStore = create<HistoryState>((set, get) => ({
  timelinePoints: [],
  selectedTimePoint: null,
  rawTimestamps: [],
  hasManualSelection: false,

  setTimelinePoints: (points) => set({ timelinePoints: points }),

  setRawTimestamps: (timestamps) => {
    set({ rawTimestamps: timestamps })
    // After setting raw timestamps, generate the timeline
    get().generateTimelineFromTimestamps()
  },

  generateTimelineFromTimestamps: () => {
    const { rawTimestamps, hasManualSelection, selectedTimePoint } = get()

    if (rawTimestamps.length === 0) {
      // If no timestamps, create a default point with current time
      const now = new Date()
      const defaultPoint = {
        timestamp: now,
        label: format(now, "h:mm a"),
        isLatest: true,
      }

      set({
        timelinePoints: [defaultPoint],
        selectedTimePoint: defaultPoint,
        hasManualSelection: false,
      })
      return
    }

    // Sort timestamps in ascending order (oldest first)
    const sortedTimestamps = [...rawTimestamps].sort((a, b) => a.getTime() - b.getTime())

    // Create timeline points from all timestamps
    const timelinePoints: TimelineDataPoint[] = sortedTimestamps.map((timestamp, index) => {
      const isLatest = index === sortedTimestamps.length - 1
      return {
        timestamp,
        label: format(timestamp, "h:mm a"),
        isLatest,
      }
    })

    set({ timelinePoints })

    // Auto-select latest point only on initial load (when no point is selected)
    if (!selectedTimePoint) {
      const latestPoint = timelinePoints[timelinePoints.length - 1]
      console.log("Initial load - auto-selecting latest point:", latestPoint?.label)
      set({
        selectedTimePoint: latestPoint,
        hasManualSelection: false,
      })
    }
  },

  autoSelectLatestOnPolling: () => {
    const { timelinePoints } = get()

    // Always auto-select latest point on polling refresh, regardless of manual selection
    if (timelinePoints.length > 0) {
      const latestPoint = timelinePoints[timelinePoints.length - 1]
      console.log("Polling refresh - auto-selecting latest point:", latestPoint?.label, "(ignoring manual selection)")
      set({
        selectedTimePoint: latestPoint,
        // Reset hasManualSelection since we're forcing auto-selection
        hasManualSelection: false,
      })
    }
  },

  setSelectedTimePoint: (point, isManual = false) => {
    console.log("Setting selected point:", point?.label, "isManual:", isManual)
    set({
      selectedTimePoint: point,
      // Set hasManualSelection to true if this is a manual selection
      hasManualSelection: isManual || get().hasManualSelection,
    })
  },
}))
